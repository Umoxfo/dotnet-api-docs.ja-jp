<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c495a3f66b3c69ecf66c5486200d8593af023e9b" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48675063" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>擬似乱数ジェネレーターを表します。擬似乱数ジェネレーターは、乱数についての統計的な要件を満たす数値系列を生成するデバイスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数値の有限のセットから等しい確率で擬似乱数が選択されます。 選択し、数学的アルゴリズムが使用されるが、実際には十分にランダムなために、選択した番号は完全にランダムではありません。 現在の実装、<xref:System.Random>クラスは E. Donald Knuth の減算乱数ジェネレーター アルゴリズムの変更版に基づいています。 詳細については、D. E. を参照してください。 クヌースします。 *コンピューターのプログラミングでは、ボリューム 2 のアート: Seminumerical アルゴリズム*します。 Addison Wesley、読み取り、MA、3 番目のエディション、1997 です。  
  
 ランダムなパスワードを作成するのに適したものなどの暗号強度が高いランダムな数値を生成するには使用、<xref:System.Security.Cryptography.RNGCryptoServiceProvider>クラスまたは派生クラスを<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>します。  
  
 このトピックの内容:  
  
 [乱数ジェネレーターをインスタンス化します。](#Instantiate)   
 [複数のインスタンス化を回避します。](#Multiple)   
 [System.Random クラスおよびスレッドの安全性](#ThreadSafety)   
 [さまざまな種類の乱数を生成します。](#Functionality)   
 [独自のアルゴリズムの置換](#Overriding)   
 [System.Random を使用するには.](#Operations)   
 [ランダムな値の同じシーケンスを取得します。](#Same)  
 [ランダムな値の一意のシーケンスを取得します。](#Unique)  
 [指定した範囲の整数を取得します。](#Range)  
 [指定した桁数を持つ整数を取得します。](#Digits)  
 [指定した範囲の浮動小数点値を取得します。](#Floats)  
 [ランダムなブール値を生成します。](#Boolean)  
 [64 ビットの整数の乱数を生成します。](#Long)  
 [指定した範囲内のバイトを取得します。](#Bytes)  
 [配列またはコレクションから要素をランダムに取得します。](#Array)  
 [配列またはコレクションからの一意の要素を取得します。](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>乱数ジェネレーターをインスタンス化します。  
 シード値 (擬似乱数生成アルゴリズムの開始値) を提供することで、乱数ジェネレーターをインスタンス化する、<xref:System.Random.%23ctor%2A>クラスのコンス トラクター。  明示的または暗黙的にシード値を指定できます。  
  
-   <xref:System.Random.%23ctor%28System.Int32%29>コンス トラクターは指定する明示的なシード値を使用します。  
  
-   <xref:System.Random.%23ctor>コンス トラクターでは、システム クロックを使用して、シード値を提供します。 これは、乱数ジェネレーターをインスタンス化する最も一般的な方法です。  
  
 同じシードが個別に使用される場合<xref:System.Random>オブジェクト、同じ一連のランダムな番号が生成されます。 乱数値を処理するテスト スイートを作成するため、またはそのデータをランダムな数値から派生したゲームを再生するために役立ちます。 ことができます。 ただし、<xref:System.Random>同一のシード値がインスタンス化している場合でも、異なるバージョンの .NET Framework で実行されているプロセス内のオブジェクトが別の一連のランダムな数値を返す可能性があります。  
  
 ランダムな数値のさまざまなシーケンスを生成するために行うことができます、シード値時間に依存のための新しいインスタンスごとに別の系列を生成<xref:System.Random>します。 パラメーター化された<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクターがかかることができます、<xref:System.Int32>値に基づいてタイマー刻みの数、現在の時刻では、パラメーターなし<xref:System.Random.%23ctor>コンス トラクターでは、システム クロックを使用して、シード値を生成します。 ただし、クロックは有限の解像度があるために、このパラメーターなしのコンス トラクターを異なるを作成する使用<xref:System.Random>連続でオブジェクトが同一のシーケンスのランダムな数値を生成する乱数ジェネレーターを作成します。 次の例 2 つ<xref:System.Random>連続でインスタンス化されるオブジェクトは、同一の一連のランダムな数値を生成します。 ほとんどの Windows システムで<xref:System.Random>互いの 15 ミリ秒以内に作成されたオブジェクトが同一のシード値を持つ可能性があります。  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 この問題を回避するには、1 つを作成<xref:System.Random>複数のオブジェクトではなくオブジェクト。  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>複数のインスタンス化を回避します。  
 2 つの random number generator または立て続けに短いループ内の初期化中には、ランダムな数値の同一のシーケンスを生成できる 2 つの random number generator が作成されます。 ほとんどの場合、これは、開発者の意図でありをインスタンス化し、乱数ジェネレーターの初期化がプロセスが比較的安価であるため、パフォーマンスの問題につながることができます。  
  
 両方のパフォーマンスを向上させるために、誤って同じ数値のシーケンスを生成する別の random number generator を作成しないようにする、1 つを作成すること勧め<xref:System.Random>オブジェクトを作成する代わりに、時間の経過と共に多くの乱数を生成するには新しい<xref:System.Random>1 つの乱数を生成するオブジェクト。  
  
 ただし、<xref:System.Random>クラスは、スレッド セーフであります。 呼び出す場合<xref:System.Random>、複数のスレッドからメソッドが次のセクションで説明されているガイドラインに従います。  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random クラスおよびスレッドの安全性  
 個々の<xref:System.Random>オブジェクトをインスタンス化するのではなく、同一のインスタンスからアプリケーションが必要とするすべての乱数を生成することをお勧めします。 ただし、<xref:System.Random>オブジェクトはスレッド セーフではありません。 アプリを呼び出す場合<xref:System.Random>複数のスレッドからメソッド、1 つのスレッドが一度に乱数ジェネレーターをアクセスできるようにする同期オブジェクトを使用する必要があります。 いることを確認しない場合、<xref:System.Random>オブジェクトがスレッド セーフな方法でアクセスされる、ランダムな数値を返すメソッドを呼び出すには 0 が返されます。  
  
 次の例では、c# 使用[lock ステートメント](~/docs/csharp/language-reference/keywords/lock-statement.md)および Visual Basic [SyncLock ステートメント](~/docs/visual-basic/language-reference/statements/synclock-statement.md)を 1 つ乱数ジェネレーターにスレッド セーフ方式で 11 のスレッドによってアクセスすることを確認します。 各スレッドで 200万の乱数を生成し生成されたランダムな数字の数をカウント、その合計を計算し、実行が完了すると、すべてのスレッドの合計を更新します。  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 例では、次の方法でスレッド セーフを保証します。  
  
-   <xref:System.ThreadStaticAttribute>乱数を生成し、スレッドごとに、その合計の合計数を追跡するスレッド ローカル変数を定義する属性を使用します。  
  
-   ロック (、 `lock` (C#) ステートメント、 `SyncLock` Visual Basic でのステートメント) の合計数とすべてのスレッドで生成されたすべてのランダムな数の合計、変数へのアクセスを保護します。  
  
-   セマフォ (、<xref:System.Threading.CountdownEvent>オブジェクト)、メイン スレッドがブロックまで他のすべてのスレッドが実行を完了することを確認するために使用します。  
  
-   この例では、かどうか、乱数ジェネレーターが破損を特定することにランダムな番号の生成方法の 2 つの連続した呼び出しは、0 を返すかどうかを確認します。 破損が検出された場合の例では、<xref:System.Threading.CancellationTokenSource>オブジェクトからすべてのスレッドを取り消す必要があることを通知します。  
  
-   状態を調べ、各スレッドごとの乱数を生成する前に、<xref:System.Threading.CancellationToken>オブジェクト。 キャンセルが要求される場合の例では、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>スレッドをキャンセルするメソッド。  
  
 使用する点を除いて、次の例は、最初と同じ、<xref:System.Threading.Tasks.Task>オブジェクトとラムダ式の代わりに<xref:System.Threading.Thread>オブジェクト。  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 最初の例から次の方法で異なります。  
  
-   使用する必要はありませんので、生成されたランダムな数字の数と各タスクでは、その合計を追跡する変数はタスクは、ローカル、<xref:System.ThreadStaticAttribute>属性。  
  
-   静的な<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>メソッドを使用して、すべてのタスクが完了する前に、メイン スレッドが完了しないことを確認します。 必要はありません、<xref:System.Threading.CountdownEvent>オブジェクト。  
  
-   タスクのキャンセルに起因する例外が表示される、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>メソッド。 前の例では、各スレッドで処理されます。  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>さまざまな種類の乱数を生成します。  
 乱数ジェネレーターは、次の種類の乱数を生成できるメソッドを提供します。  
  
-   一連の<xref:System.Byte>値。 メソッドに戻るようにする要素の数に初期化された配列を渡すことによってバイト値の数を決定する、<xref:System.Random.NextBytes%2A>メソッド。 次の例では、20 バイトを生成します。  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   1 つの整数。 最大値は 0 から整数にするかどうかを選択できます (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) を呼び出して、<xref:System.Random.Next>メソッドは、0 から呼び出すことによって、特定の値までの整数、<xref:System.Random.Next%28System.Int32%29>メソッド、または、を呼び出すことによって値の範囲内の整数<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッド。 パラメーター化されたオーバー ロードで指定された最大値は排他的です。生成された実際の最大数は、1 つは、指定した値より小さくします。  
  
     次の例では、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -10 ~ 10 の間の 10 個の乱数を生成します。 メソッドの 2 番目の引数がメソッドによって返されるランダムな値の範囲の上限を指定することに注意してください。 つまり、メソッドは、1 つを返すことができる最大の整数値よりも小さい値です。  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   呼び出すことによって 1.0 より小さい 0.0 から 1 つの浮動小数点値、<xref:System.Random.NextDouble%2A>メソッド。 メソッドによって返される乱数の排他的上限値は、その実際の上限は 0.99999999999999978 1 です。 次の例では、10 個のランダムな浮動小数点数値を生成します。  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドでは、返される乱数の範囲を指定できます。 ただし、`maxValue`範囲の上限に返される数値を指定するには、パラメーターは、排他、包括、いない値。 つまり、メソッドの呼び出し`Next(0, 100)`0 ~ 99 の範囲演算子と not between 0 と 100 の値を返します。  
  
 使用することも、<xref:System.Random>などのタスクを生成するためのクラス[ランダム T:System.Boolean 値](#Boolean)生成、[ランダムな浮動小数点値以外の 0 ~ 1 の範囲で](#Floats)を生成する[64 ビットの整数の乱数](#Long)、および[の一意の要素を配列またはコレクションからランダムに取得](#UniqueArray)します。 これらおよびその他の一般的なタスクは、次を参照してください、 [System.Random を使用する.。](#Operations) セクション。  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>独自のアルゴリズムの置換  
 継承することによって、独自の乱数を実装することができます、<xref:System.Random>クラスと乱数の生成アルゴリズムを指定します。 オーバーライドする必要があります、独自のアルゴリズムを指定する、<xref:System.Random.Sample%2A>メソッドで、乱数生成アルゴリズムを実装します。 オーバーライドすることも必要があります、 <xref:System.Random.Next>、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>、および<xref:System.Random.NextBytes%2A>メソッドのオーバーライドを呼び出すことを確認する<xref:System.Random.Sample%2A>メソッド。 オーバーライドする必要はありません、<xref:System.Random.Next%28System.Int32%29>と<xref:System.Random.NextDouble%2A>メソッド。  
  
 派生する例については、<xref:System.Random>クラスし、その既定擬似乱数ジェネレーター、変更を参照してください、<xref:System.Random.Sample%2A>リファレンス ページです。  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>System.Random を使用するには.  
 次のセクションでは、説明し、ランダムな数値をアプリで使用する方法のいくつかのサンプル コードを提供します。  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>ランダムな値の同じシーケンスを取得します。  
 ゲームのプレイとソフトウェア テスト シナリオで同じランダムな数値のシーケンスを生成することがあります。 ランダムな数値のシーケンスが同じテストを使用すると、回帰を検出し、バグの修正を確認できます。 ゲームで同じランダムな数値のシーケンスを使用して以前のゲームを再生することができます。  
  
 同じシード値を提供することで同じランダムな数値のシーケンスを生成することができます、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター。 シード値は、擬似乱数生成アルゴリズムの開始値を提供します。 次の例では、任意のシード値として 100100 をでインスタンス化する、<xref:System.Random>オブジェクト、20 個のランダムな浮動小数点値を表示およびシード値が引き続き発生します。 シード値を復元する、新しいランダムな番号ジェネレーターのインスタンスを作成し、20 同じのランダムな浮動小数点値を表示します。  例も、異なるバージョンの .NET Framework 上で実行する場合に、ランダムな数値のさまざまなシーケンスを生成可能性がありますに注意してください。  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>乱数の一意のシーケンスを取得します。  
 インスタンスに異なるシード値を提供する、<xref:System.Random>クラスにより各乱数ジェネレーターの値のさまざまなシーケンスを生成します。 シード値を明示的に呼び出していずれかで行うことができます、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター、または暗黙的に呼び出して、<xref:System.Random.%23ctor>コンス トラクター。 ほとんどの開発者は、システム クロックを使用してパラメーターなしのコンス トラクターを呼び出します。 次の例では、このアプローチを使用して 2 つのインスタンスを作成する<xref:System.Random>インスタンス。 各インスタンスは、一連の 10 個のランダムな整数を表示します。  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 ただし、有限の解像度のため、システム クロックが約 15 ミリ秒未満である時間の相違点を検出しません。 そのため、コードを呼び出す場合、 <xref:System.Random.%23ctor> 2 つのインスタンスを作成するオーバー ロード<xref:System.Random>する可能性がありますが誤ってするオブジェクトを提供する、同一のシード値を連続してオブジェクトします。 前の例では、これを参照してくださいをコメント アウト、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドの呼び出しとコンパイルと実行の例をもう一度です。  
  
 これが事態を防ぐためにお勧め、1 つのインスタンスを作成する<xref:System.Random>複数のではなくオブジェクトします。 ただし、<xref:System.Random>いないスレッド セーフであるためにアクセスする場合は、いくつかの同期デバイスを使用する必要があります、<xref:System.Random>詳細については複数のスレッドからのインスタンスは、「 [、ランダムなクラスおよびスレッドの安全性](#ThreadSafety)この以前トピックです。 など、遅延メカニズムを使用する代わりに、<xref:System.Threading.Thread.Sleep%2A>メソッドの前の例では、インスタンス化には、15 を超えるミリ秒間隔が発生することを確認するために使用します。  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>指定した範囲の整数を取得します。  
 指定した範囲の整数を取得するには呼び出すことによって、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドは、返される乱数ジェネレーターの数値の上限と下限を指定することができます。 上限は、排他、包括、いない値です。 つまり、メソッドによって返される値の範囲に含まれていません。 次の例では、このメソッドを使用して、-10 ~ 10 の間の整数の乱数を生成します。 1 つの値として、目的の値よりも大きい値である、11 を指定しているメモの`maxValue`メソッド呼び出しの引数。  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>指定した桁数を持つ整数を取得します。  
 呼び出すことができます、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>指定した桁数で数値を取得します。 呼び出すこと (1000 から 9999 の範囲数) の 4 桁の番号を取得するには、たとえば、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドを`minValue`値は 1000 と`maxValue`として次の例は、10000 の値。  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>指定した範囲の浮動小数点値を取得します。  
 <xref:System.Random.NextDouble%2A>メソッド 0 を返しますランダムな浮動小数点値の範囲を 1 未満にします。 ただし、多くの場合、たいその他のいくつかの範囲にランダムな値を生成します。  
  
 によって返される数に必要な開始時間間隔と 0 の違いを追加するには必要な最小値と最大値までの間隔が 1 の場合、<xref:System.Random.NextDouble%2A>メソッド。 次の例は、-1 から 0 までの 10 個の乱数を生成します。  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 浮動小数点乱数を生成する下限は 0 が、上限は 1 より大きい (または、負の数値の場合の下限の境界が-1 未満です、上限は 0)、0 以外のバインドでランダムな数値を乗算します。 次の例はこれを 2,000万浮動小数点乱数を生成する範囲 0 ~<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。 も、メソッドによって生成されるランダムな値の分布を表示します。  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 などの任意の 2 つの値の間で浮動小数点乱数を生成する、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドは、整数の場合は、次の数式を使用します。  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 次の例では、11.0 に 10.0 から 100万の乱数の範囲を生成し、その分布が表示されます。  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>ランダムなブール値を生成します。  
 <xref:System.Random>クラスを生成するメソッドを提供しません<xref:System.Boolean>値。 ただし、独自のクラスまたはそのメソッドを定義できます。 次の例では、クラスを定義する`BooleanGenerator`、単一のメソッドと`NextBoolean`します。 `BooleanGenerator`ストア クラス、<xref:System.Random>秘密の変数としてのオブジェクト。 `NextBoolean`メソッドの呼び出し、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドにより、結果と、<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>メソッド。 ランダムな数の上限を指定する引数として 2 が使用されることに注意してください。 これは、排他的な値であるため、メソッドの呼び出しは、0 または 1 を返します。  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 乱数を生成する別のクラスを作成する代わりに<xref:System.Boolean>値、例では、1 つのメソッドが定義だけでした。 ただし、その場合、<xref:System.Random>オブジェクトを新しいをインスタンス化を回避するためにクラス レベルの変数として定義する必要があります<xref:System.Random>各メソッド呼び出し内のインスタンス。 Visual basic でとして Random インスタンスを定義することができます、[静的](~/docs/visual-basic/language-reference/modifiers/static.md)変数、`NextBoolean`メソッド。  次の例は、実装を提供します。  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>64 ビットの整数の乱数を生成します。  
 オーバー ロード、<xref:System.Random.Next%2A>メソッドは、32 ビット整数を返します。 ただし、場合によっては、64 ビット整数を使用する必要があります。 このことは次のように実行できます。  
  
1.  呼び出す、<xref:System.Random.NextDouble%2A>取得倍精度浮動小数点値。  
  
2.  その値に乗算<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。  
  
 次の例では、この手法を使用して、20 件の長整数の乱数を生成するし、10 個のと同じグループ内に分類されています。 0 から、各グループ内の数をカウントすることによってランダムな数値の分布を評価し、<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。 例の出力に示すよう番号が長整数の範囲を増減均等に分散されます。  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 ビットの操作を使用する代替手法は、真の乱数を生成しません。 この手法を呼び出す<xref:System.Random.Next>2 つの整数、左シフト 1 で 32 ビット、および Or を生成することです。 この手法では、2 つの制限があります。  
  
1.  31 ビットは符号ビットであるため、結果の長整数のビット 31 の値は常に 0 です。  これは、31 ビット、および論理和をランダムな 0 または 1、左シフトを生成することによって対処できますで元のランダムな long 整数。  
  
2.  重大、ため、によって返される値の確率<xref:System.Random.Next>の場合は 0 には存在する場合は、少数のランダムな数値範囲 0x0 0x00000000FFFFFFFF で。  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>指定した範囲内のバイトを取得します。  
 オーバー ロード、<xref:System.Random.Next%2A>メソッドを使用する乱数の範囲を指定できますが、<xref:System.Random.NextBytes%2A>メソッドはありません。 次の例では、実装、`NextBytes`メソッドが返されるバイトの範囲を指定することができます。 定義、`Random2`クラスから派生した<xref:System.Random>オーバー ロードとその`NextBytes`メソッド。  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)`メソッドへの呼び出しをラップします、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッド最小値と最大値よりも大きい 1 つを指定します (この場合は、0 と 101) バイト配列で返されるようにします。 整数値がによって返されることを確認していますので、<xref:System.Random.Next%2A>の範囲内のメソッドは、<xref:System.Byte>データ型、おできます安全にキャストに (c#) に変換したり (Visual Basic) で整数からバイト。  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>配列またはコレクションから要素をランダムに取得します。  
 ランダムな数値は、多くの場合、配列またはコレクションから値を取得するインデックスとして機能します。 ランダムなインデックス値を取得するを呼び出すことができます、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドをおよびの値としての配列の下限値を使用してその`minValue`引数と 1 つの値として、配列の上限を超えるその`maxValue`引数。 これに相当の 0 から始まる配列の場合は、その<xref:System.Array.Length%2A>プロパティ、またはいずれかによって返される値より大きい、<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>メソッド。 次の例は、都市の配列からランダムに米国の州の都市の名前を取得します。  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>配列またはコレクションからの一意の要素を取得します。  
 乱数ジェネレーターは、重複する値を常に返すことができます。 番号の範囲が小さくなります。 または、生成された値の数が大きくなる、重複の確率が大きくなります。 ランダムな値は一意である必要があります、他の番号は、パフォーマンスが低下ますます重複を補正するために生成されます。  
  
 このシナリオを処理するための手法を数多くあります。 1 つの一般的な解決策では、配列やコレクションを取得する値を格納する浮動小数点乱数を格納する並列配列を作成します。 2 番目の配列はランダムな数値では、最初の配列の作成時に設定されます。 および<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>メソッドは並列配列の値を使用して、最初の配列を並べ替えに使用します。  
  
 など、ソリティア ゲームを開発する場合に各カードが 1 回だけ使用されるようにします。 カードとカードが処理済みかどうかを追跡を取得する乱数を生成するには、代わりに、デッキの並べ替えに使用できるランダムな数値の並列配列を作成できます。 デッキが並べ替えられると、アプリは次のカード デッキでのインデックスを示しますへのポインターを維持できます。  
  
 このアプローチの例を次に示します。 定義、`Card`クラスとトランプを表す`Dealer`トランプのシャッフルを処理するクラス。 `Dealer`クラスのコンス トラクターは 2 つの配列を設定します、`deck`クラス スコープを持つと、すべてのカード デッキ; とローカルを表す配列`order`を持つ同じ数の要素の配列、`deck`配列とは設定されます。ランダムに生成された<xref:System.Double>値。  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>並べ替えメソッドが呼び出されてから、`deck`内の値に基づいて配列、`order`配列。  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 次の例では、単一乱数ジェネレーターと呼び出しを作成します。 その<xref:System.Random.NextBytes%2A>、 <xref:System.Random.Next%2A>、および<xref:System.Random.NextDouble%2A>さまざまな範囲内のランダムな数値のシーケンスを生成するメソッド。  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 次の例は、インデックスとして使用される整数の乱数を生成する、配列から文字列値を取得します。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>派生したクラスの最低限の実装では、.NET Framework 1.0 および 1.1 では、<see cref="T:System.Random" />をオーバーライドするために必要な<see cref="M:System.Random.Sample" />乱数を生成するための新しいまたは変更されたアルゴリズムを定義するメソッド。 派生クラスの基本クラスの実装に任せるでした、 <see cref="M:System.Random.Next" />、 <see cref="M:System.Random.Next(System.Int32)" />、 <see cref="M:System.Random.Next(System.Int32,System.Int32)" />、 <see cref="M:System.Random.NextBytes(System.Byte[])" />、および<see cref="M:System.Random.NextDouble" />の派生クラスの実装を呼び出すメソッドを<see cref="M:System.Random.Sample" />メソッド。  
  
.NET Framework 2.0 以降の動作で、 <see cref="M:System.Random.Next" />、 <see cref="M:System.Random.Next(System.Int32,System.Int32)" />、および<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッドがこれらのメソッドの派生クラスの実装を必ずしも呼び出すはありませんができるように変更されて、<see cref="M:System.Random.Sample" />メソッド。 派生するクラスの結果として、 <see cref="T:System.Random" /> .NET Framework 2.0 をターゲットして、後でこれら 3 つのメソッドをオーバーライドする必要がありますもします。</para>
    </block>
    <block subset="none" type="usage">
      <para>乱数ジェネレーターの実装、<see cref="T:System.Random" />クラスは、同じままで、.NET Framework のメジャー バージョン間で保証されません。 その結果、同じシードは、.NET Framework のさまざまなバージョンで同じ擬似乱数シーケンスになりますとは考えないでください。</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>時間に応じて決定される既定のシード値を使用し、<see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のシード値では、システム クロックからは派生し、有限の解像度があります。 その結果、異なる<xref:System.Random>連続で既定のコンス トラクターへの呼び出しによって作成されるオブジェクトと同じ既定のシード値になり、そのため、まったく同じ乱数のセットが生成されます。 この問題を回避するには、1 つを使用して<xref:System.Random>すべての乱数を生成するオブジェクト。 システム クロックによって返されるシード値を変更しをこの新しいシード値を明示的に提供することによって、対処することも、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター。 詳細については、次を参照してください。、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター。  
  
 乱数ジェネレーターのランダム シーケンスを生成する場合は、このコンス トラクターを呼び出します。 異なる乱数ジェネレーターの同じ乱数の固定のシーケンスを生成するには、呼び出し、<xref:System.Random.%23ctor%28System.Int32%29>固定のシード値を持つコンス トラクター。 これは、<xref:System.Random>コンス トラクター オーバー ロードは、ランダムな数字を使用するアプリをテストするときによく使用します。  
  
 各を呼び出す、乱数ジェネレーターをインスタンス化した後<xref:System.Random>メソッドなど<xref:System.Random.Next>または<xref:System.Random.NextDouble>乱数を生成します。  
  
   
  
## Examples  
 次の例では、3 つのインスタンスを作成する既定のコンス トラクターを使用して<xref:System.Random>オブジェクトし、それぞれの 5 つのランダムな整数のシーケンスが表示されます。 ため、最初の 2 つ<xref:System.Random>オブジェクトが作成連続で、システム クロックに基づく同一のシード値を使用してインスタンス化され、そのため、ランダムな数値のシーケンスが同じ生成します。 その一方で、3 つ目の既定のコンス トラクター<xref:System.Random>オブジェクトが呼び出すことによって引き起こされる 2 秒間遅延後に呼び出されると、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッド。 3 番目の異なるシード値が生成されますので<xref:System.Random>オブジェクトのさまざまな一連のランダムな数値が生成されます。  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">擬似乱数系列の開始値を計算するために使用する数値。 負数を指定した場合、その数値の絶対値が使用されます。</param>
        <summary>指定したシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 別の同一のシード値を提供する<xref:System.Random>と、ランダムな数値の同一のシーケンスを生成するために各インスタンスのオブジェクト。 乱数ジェネレーターに依存するアプリをテストするときにこれは多くの場合です。  
  
 アプリケーションは、さまざまなランダムな番号のシーケンスを必要とする場合は、異なるシード値を繰り返し、このコンス トラクターを呼び出します。 一意のシード値を生成する方法の 1 つは、時間に依存するようにすることです。 たとえば、として、システム クロックからシード値の取得、<xref:System.Random.%23ctor>オーバー ロードは。 ただし、システム クロックは異なるシード値にこのコンス トラクターの別の呼び出しを提供するための十分な解決策があります。 最初の 2 つに示すように、擬似乱数のと同じシーケンスを生成する乱数ジェネレーターでこの結果<xref:System.Random>次の例では、内のオブジェクト。 これを回避するには、各呼び出しでは、または呼び出しでシード値を区別するアルゴリズムを適用、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドを異なるシード値を持つ各コンス トラクターを提供することを確認します。  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 1 つのインスタンスを作成することも<xref:System.Random>オブジェクト使用して、アプリケーションですべての乱数を生成することです。 かなり安価では、乱数ジェネレーターのインスタンス化であるために、若干優れたパフォーマンスが得られます。  
  
   
  
## Examples  
 次の例では、作成<xref:System.Random>シード パラメーターを受け取るし、ランダムな整数と double のシーケンスを生成するクラスのコンス トラクターを持つオブジェクト。 例を示しますが、同じシーケンスを生成するときに、<xref:System.Random>コンス トラクターとシード パラメーターを使用してオブジェクトを再作成します。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ランダムな整数を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0 以上のランダムな整数を返します。</summary>
        <returns>0 以上で <see cref="F:System.Int32.MaxValue" /> より小さい 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> 0 ~ 値の範囲の乱数を生成します。 より小さい<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。 その他のいくつかの正の数を 0 から値の範囲の乱数を生成するには、使用、<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>メソッドのオーバー ロードします。 別の範囲内の乱数を生成するには、使用、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例を繰り返し呼び出すので、<xref:System.Random.Next%2A>特定の数のユーザーによって要求された乱数を生成します。 <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>メソッドを使用して、顧客の入力を取得します。  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 次の例では、派生クラスを<xref:System.Random>によって生成された一様分布からの配布とは異なるランダムな数値のシーケンスを生成する、<xref:System.Random.Sample%2A>基本クラスのメソッド。 これは、上書き、<xref:System.Random.Sample%2A>ランダムな数字、および上書きの分布を提供するメソッドを<xref:System.Random.Next%2A?displayProperty=nameWithType>一連のランダムな数字を使用する方法。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。実装、<see cref="M:System.Random.Next" />メソッド。 一様分布がベースによって返される代わりに、<see cref="T:System.Random" />クラスを使用します。 この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。 呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />派生クラスでメソッドをオーバーライドすることする必要がありますも、<see cref="M:System.Random.Next" />メソッド。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">生成される乱数の排他的上限値。 <c>maxValue</c> には、0 以上の値を指定してください。</param>
        <summary>指定した最大値より小さい 0 以上のランダムな整数を返します。</summary>
        <returns>0 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付き整数。つまり、通常は戻り値の範囲に 0 は含まれますが、<paramref name="maxValue" /> は含まれません。 ただし、<paramref name="maxValue" /> が 0 の場合は、<paramref name="maxValue" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29>オーバー ロードは 0 からランダムな整数の範囲を返します`maxValue`– 1。 ただし場合、`maxValue`が 0 の場合、メソッドは 0 を返します。  
  
   
  
## Examples  
 次の例では、ランダムな整数のさまざまなオーバー ロードを持つ、<xref:System.Random.Next%2A>メソッド。  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 次の例は、インデックスとして使用される整数の乱数を生成する、配列から文字列値を取得します。 配列の最も大きいインデックスが 1 つ未満の長さ、値のため、<xref:System.Array.Length%2A?displayProperty=nameWithType>としてプロパティを指定する、`maxValue`パラメーター。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">返される乱数の包括的下限値。</param>
        <param name="maxValue">返される乱数の排他的上限値。 <c>maxValue</c> には、<c>minValue</c> 以上の値を指定してください。</param>
        <summary>指定した範囲内のランダムな整数を返します。</summary>
        <returns>
          <paramref name="minValue" /> 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付整数。つまり、戻り値の範囲に <paramref name="minValue" /> は含まれますが <paramref name="maxValue" /> は含まれません。 <paramref name="minValue" /> が <paramref name="maxValue" /> と等しい場合は、<paramref name="minValue" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>オーバー ロードはその範囲からランダムな整数を返します`minValue`に`maxValue`– 1。 ただし場合、 `maxValue` equals `minValue`、メソッドを返します`minValue`します。  
  
 その他のオーバー ロードとは異なり、<xref:System.Random.Next%2A>のみ負でない値を返すには、メソッドは、このメソッドは負の整数の乱数を返すことができます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 3 つの異なる範囲の整数の乱数を生成します。 例では、実際の出力に渡されるシステム提供のシード値によって異なります、<xref:System.Random>クラスのコンス トラクター。  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 次の例は、インデックスとして使用される整数の乱数を生成する、配列から文字列値を取得します。 配列の最も大きいインデックスが 1 つ未満の長さ、値のため、<xref:System.Array.Length%2A?displayProperty=nameWithType>としてプロパティを指定する、`maxValue`パラメーター。  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> が <paramref name="maxValue" /> より大きくなっています。</exception>
        <block subset="none" type="overrides">
          <para>クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。実装、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />場合、メソッドがオーバー ロードの違い、<paramref name="minValue" />と<paramref name="maxValue" />パラメーターがより大きい<see cref="F:System.Int32.MaxValue" />します。 一様分布がベースによって返される代わりに、<see cref="T:System.Random" />クラスを使用します。 この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。 呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />派生クラスでメソッドをオーバーライドすることする必要がありますも、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />メソッドのオーバー ロードします。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">乱数を格納するバイト配列。</param>
        <summary>指定したバイト配列の要素に乱数を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バイトの配列の各要素に設定されているランダムな数より大きいまたは 0 に等しいまたはそれよりも小さいと<xref:System.Byte.MaxValue>します。  
  
 たとえば、ランダムなパスワードを作成するための適切な暗号で保護されたランダムな数値を生成するメソッドなど、使用<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例では、使用する方法、<xref:System.Random.NextBytes%2A>メソッドでランダムなバイト値を含むバイト配列を設定します。  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <block subset="none" type="overrides">
          <para>クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。実装、<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッド。 一様分布がベースによって返される代わりに、<see cref="T:System.Random" />クラスを使用します。 この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。 呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />派生クラスでメソッドをオーバーライドすることする必要がありますも、<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッド。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 以上 1.0 未満のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される乱数の実際の上限は、0.99999999999999978 です。  
  
 0.0 と 1.0 以外の範囲内のランダムな浮動小数点値を取得するには、「指定された範囲の浮動小数点値を取得」のセクションを参照してください。、<xref:System.Random>クラスに関するトピック。  
  
 このメソッドは、保護されたメソッドのパブリック バージョン<xref:System.Random.Sample%2A>します。  
  
   
  
## Examples  
 次の例では、<xref:System.Random.NextDouble%2A>ランダムな倍精度小数点数のシーケンスを生成するメソッド。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 次の例では、 <xref:System.Random.NextDouble%2A> 100 の乱数を生成するメソッドを番号し、その頻度分布が表示されます。  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 と 1.0 の間のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスを別のランダムな配布や、異なる乱数ジェネレーターの原則を生成する、<xref:System.Random>クラスし、オーバーライド、<xref:System.Random.Sample%2A>メソッド。  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A>メソッドは`protected`、内でのみアクセス可能であることを意味する、<xref:System.Random>クラスとその派生クラス。 0 から 1 の乱数を生成する、<xref:System.Random>インスタンスを呼び出し、<xref:System.Random.NextDouble%2A>メソッド。  
  
   
  
## Examples  
 次の例では、派生クラスを<xref:System.Random>をオーバーライドし、<xref:System.Random.Sample%2A>ランダムな数値の分布を生成します。 この分布はによって生成された一様分布とは異なる、<xref:System.Random.Sample%2A>基本クラスのメソッド。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。次のメソッドの実装: 
-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッド。  
  
-   <see cref="M:System.Random.Next" /> メソッド。  
  
-<see cref="M:System.Random.Next(System.Int32,System.Int32)" />メソッド場合 (<paramref name="maxValue" /> - <paramref name="minValue" />) よりも大きい<see cref="F:System.Int32.MaxValue" />します。  
  
一様分布がベースによって提供される代わりに、<see cref="T:System.Random" />クラスを使用します。 この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。 実装を呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />メソッド、派生クラスでは、これら 3 つのメンバーの動作もオーバーライドする必要があります。 具体的な例を次に示します。</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
